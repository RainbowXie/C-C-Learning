# 树

## 树定义
* 专业定义：
1. 有且只有称为根的节点
2. 有若干个互不相交的子树，这些子树本身也是一棵树
* 通俗的定义：
1. 树是由节点和边（指针域）组成
2. 每个节点只有一个父节点但可以有多个子节点
3. 根节点没有父节点
* 专业术语
    * 节点
    * 父节点
    * 子节点
    * 子孙
    * 堂兄弟
    * 深度
        * 从根节点到最底层节点的层数称之为深度
        * 根节点是第一层
    * 叶子节点：
        * 没有子节点的节点
    * 非终端节点
        * 实际就是非叶子节点
    * 度
        * 子节点的个数称为度
## 树分类

### 一般树
任意一个子节点的个数都不受限制

### 二叉树
任意一个节点的子节点个数最多两个， 且子节点的位置不可更改
#### 分类:
* 一般二叉树
* 满二叉树
    * 在不增加树的层数的前提下，无法再多添加一个节点的二叉树
* 完全二叉树
    * 如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树

### 森林  
n个互不相交的树的集合  

## 树的存储  

### 二叉树的存储  
二叉树是非线性结构，而存储器是线性结构，所以二叉树的存储不能直接存储，要依据某种规则。                       
于是我们创造三种规则：先序遍历、中序遍历、后序遍历。来把树转换为线性结构，三种规则将树转换为不同的结构进行存储。

在进行存储时，如果只存放有效节点，我们无法根据存储的节点还原出原来的二叉树，所以不能这样存储。
所以在存储时，要将树转化为完全二叉树，将没有的节点补齐。

1. 连续存储[完全二叉树]  
* 优点：
    * 查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快
* 缺点：
    * 耗用内存空间过大
2. 链式存储  




### 一般树的存储  
1. 双亲表示法
    * 结构体数组实现
    * 寻找父节点容易

    ```graphTD
        A["A"]
        A-->B[B]
        A-->C(C);
        A-->D(D);
        C-->E(E);
    ```

    |0|A|-1|
    |:--:|:---:|:----:|
    |1|B|0|
    |2|D|0|
    |3|E|4|
    |4|C|0|


2. 孩子表示法
    * 寻找子节点容易
    ```graphTD
        A["A"]
        A-->B[B]
        A-->C(C);
        A-->D(D);
        D-->G(G);
        B-->E(E);
        B-->F(F);
    ```
    
    
    |A|->B->C->D(指向下一个子节点的指针)|
    |:---:|:----:|
    |B|->E->F|
    |C|^|
    |D|->G|
    |E|^|
    |F|^|
    |G|^|
    
3. 双亲孩子表示法
    * 求父节点和子节点都很方便
    ```graphTD
        A["A"]
        A-->B[B]
        B-->C(C);
        C-->D(D);
        C-->E(E);
        C-->F(F);
    ```
    |0|E|4|^|
    |:---:|:---:|:---:|:---:|
    |1|F|4|^|
    |2|B|5|->C|
    |3|D|4|^|
    |4|C|2|->D->E->F|
    |5|A|-1|->B|
4. 二叉树表示法
把一个普通树转化成二叉树来存储  
具体转换方法：  
    * 设法保证任意一个节点的左指针域指向他的第一个孩子  
    * 右指针域指向他的下一个兄弟节点  

    只要能满足此条件，就可以把一个普通树转化为二叉树
    [注]: 一个普通树转化成的二叉树一定没有右子树

### 森林的存储  

```graphTD
    A["A"];
    B[B];
    B-->C(C);
    B-->D(D);
    B-->E(E);
    E-->F(F);
    G[G];
    G-->K[K];
    K-->M;
    M-->L;
    M-->N;
    M-->Q;
    M-->P;
```
将森林转化为二叉树再进行存储，存储规则同二叉树表示法
```graphTD
A-->ept[ ]
A-->B["B"];
B-->C;
B-->G[G];
C-->ept1[ ];
C-->D;
D-->EPT8[ ];
D-->E;
E-->F;
E-->EPT9[ ];
G-->K;
G-->EPT2[ ];
K-->M;
K-->EPT3[ ];
M-->L;
M-->EPT4[ ];
L-->EPT5[ ];
L-->N;
N-->EPT6[ ];
N-->Q;
Q-->EPT7[ ];
Q-->P;

```
## 操作
### 二叉树操作

1. 遍历
    * 先序遍历
        * 先访问根节点
        * 再先序访问左子树
        * 再先序访问右子树
    * 中序遍历
        * 中序遍历左子树
        * 再访问根节点
        * 再中序遍历右子树
    * 后序遍历
        * 先中序遍历左子树
        * 再中序遍历右子树
        * 再访问根节点

    
2. 已知两种遍历序列求原始二叉树  

    通过先序和中序，或者中序和后续我们可以还原出原始的二叉树，但是通过先序和后续我们无法还原出原始的二叉树。  

    只有通过先序和中序，或通过中序和后续，才可以唯一的确定一个二叉树。  

tags: 数据结构 树

